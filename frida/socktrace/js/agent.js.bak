'use strict';

const CFG = JSON.parse('%(cfg)s');

// ---------- helpers ----------
function nowMs() { return (new Date()).getTime(); }

function readCString(ptrVal, maxLen) {
  if (ptrVal.isNull()) return null;
  try {
    return Memory.readUtf8String(ptrVal, maxLen);
  } catch (_) {
    return null;
  }
}

function sanitizeConnId(s) {
  return s.replace(/[^a-zA-Z0-9_.:@=\-+]/g, '_');
}

// ---------- native bindings ----------
const libcName = CFG.libc_name && CFG.libc_name.length ? CFG.libc_name : null;

function exp(name) {
  const m = Process.findModuleByName(libcName);
  const p = m.findExportByName(name);
  if (p === null) {
    // Try without module pinning (some platforms)
    return Module.findExportByName(null, name);
  }
  return p;
}

const p_connect     = exp('connect');
const p_send        = exp('send');
const p_recv        = exp('recv');
const p_read        = exp('read');
const p_write       = exp('write');
const p_close       = exp('close');
const p_dup         = exp('dup');
const p_dup2        = exp('dup2');
const p_dup3        = exp('dup3');
const p_fcntl       = exp('fcntl');
const p_getpeername = exp('getpeername');
const p_getsockopt  = exp('getsockopt'); // optional, best effort

if (p_fcntl === null || p_getpeername === null) {
  send({ type: 'error', message: 'Required libc symbols missing: fcntl/getpeername' });
}

// int fcntl(int fd, int cmd, ...);
const fcntl = p_fcntl ? new NativeFunction(p_fcntl, 'int', ['int', 'int', 'int']) : null;
// int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
const getpeername = p_getpeername ? new NativeFunction(p_getpeername, 'int', ['int', 'pointer', 'pointer']) : null;

const AF_UNIX = 1; // Linux
const F_GETFD = 1;

const maxFds = CFG.max_fds || 4096;
const maxBytes = CFG.max_bytes || 4096;

const whitelist = new Set(CFG.socket_paths || []);

// fd -> { path, connId, createdAtMs }
const tracked = new Map();
// fd -> { sinceMs }
const pendingConnect = new Map();

function emitOpen(fd, path, connId, how) {
  send({
    type: 'open',
    fd,
    path,
    conn_id: connId,
    how,
    ts_ms: nowMs()
  });
}

function emitClose(fd, connId, how) {
  send({
    type: 'close',
    fd,
    conn_id: connId,
    how,
    ts_ms: nowMs()
  });
}

function trackFd(fd, path, how) {
  if (!whitelist.has(path)) return;

  const connId = sanitizeConnId(`${path}:fd=${fd}:t=${nowMs()}`);
  tracked.set(fd, { path, connId, createdAtMs: nowMs() });
  emitOpen(fd, path, connId, how);
}

function untrackFd(fd, how) {
  const rec = tracked.get(fd);
  if (rec) {
    tracked.delete(fd);
    emitClose(fd, rec.connId, how);
  }
  pendingConnect.delete(fd);
}

function readSockaddrUnPath(addrPtr, addrLen) {
  // struct sockaddr_un { sa_family_t sun_family; char sun_path[108]; }
  // addrPtr points to sockaddr_un
  if (addrPtr.isNull()) return null;
  if (addrLen < 2) return null;

  try {
    const fam = addrPtr.readU16();
    if (fam !== AF_UNIX) return null;

    const pathPtr = addrPtr.add(2);
    const maxPath = Math.min(108, addrLen - 2);

    // Abstract namespace: sun_path[0] == '\0' and then name bytes
    const first = pathPtr.readU8();
    if (first === 0) {
      // Represent abstract sockets as "@name"
      const raw = pathPtr.add(1).readByteArray(Math.max(0, maxPath - 1));
      if (raw === null) return '@';
      // Convert bytes to a safe-ish hex-ish printable representation
      // Try UTF-8 first, fallback to hex
      try {
        const s = pathPtr.add(1).readUtf8String(maxPath - 1);
        return '@' + (s || '');
      } catch (_) {
        const u8 = new Uint8Array(raw);
        let hex = '';
        for (let i = 0; i < u8.length; i++) hex += u8[i].toString(16).padStart(2, '0');
        return '@' + hex;
      }
    }

    const s = pathPtr.readCString();
    if (!s || s.length === 0) return null;
    return s;
  } catch (e) {
    return null;
  }
}

function getPeerUnixPath(fd) {
  if (!getpeername) return null;

  // Allocate a generous sockaddr buffer
  const bufSize = 256;
  const addr = Memory.alloc(bufSize);
  const lenp = Memory.alloc(4);
  lenp.writeU32(bufSize);

  const rc = getpeername(fd, addr, lenp);
  if (rc !== 0) return null;

  const outLen = lenp.readU32();
  return readSockaddrUnPath(addr, outLen);
}

function enumerateAlreadyOpenFds() {
  if (!fcntl || !getpeername) return;

  for (let fd = 0; fd < maxFds; fd++) {
    // Check if fd is valid: fcntl(fd, F_GETFD) >= 0
    const v = fcntl(fd, F_GETFD, 0);
    if (v < 0) continue;

    const path = getPeerUnixPath(fd);
    if (path && whitelist.has(path)) {
      trackFd(fd, path, 'preexisting:getpeername');
    }
  }

  send({ type: 'ready', tracked_fds: tracked.size, ts_ms: nowMs() });
}

// ---------- data emit ----------
function emitData(fd, direction, bytes) {
  const rec = tracked.get(fd);
  if (!rec) return;
  if (bytes === null) return;

  // Cap size
  let n = bytes.byteLength;
  if (n > maxBytes) {
    bytes = bytes.slice(0, maxBytes);
    n = maxBytes;
  }

  send({
    type: 'data',
    fd,
    conn_id: rec.connId,
    path: rec.path,
    direction,
    size: n,
    ts_ms: nowMs()
  }, bytes);
}

// ---------- hooks ----------
function hookConnect() {
  if (!p_connect) return;

  Interceptor.attach(p_connect, {
    onEnter(args) {
      this.fd = args[0].toInt32();
      this.addr = args[1];
      this.len = args[2].toInt32();
      this.path = readSockaddrUnPath(this.addr, this.len);
    },
    onLeave(retval) {
      if (!this.path) return;
      // ret == 0 success, ret == -1 failure (errno set); EINPROGRESS possible
      const r = retval.toInt32();
      if (r === 0) {
        trackFd(this.fd, this.path, 'connect');
      } else {
        // Best-effort: if EINPROGRESS, remember it as pending
        // We cannot reliably read errno portably here without libpthread __errno_location,
        // so we track as pending if not already tracked.
        pendingConnect.set(this.fd, { sinceMs: nowMs(), path: this.path });
      }
    }
  });
}

function hookCloseAndDup() {
  if (p_close) {
    Interceptor.attach(p_close, {
      onEnter(args) {
        this.fd = args[0].toInt32();
      },
      onLeave(_retval) {
        untrackFd(this.fd, 'close');
      }
    });
  }

  // If fd is duplicated, copy tracking record
  function cloneTrack(oldfd, newfd, how) {
    const rec = tracked.get(oldfd);
    if (!rec) return;
    // Keep same path but distinct connId for per-fd file separation
    const path = rec.path;
    const connId = sanitizeConnId(`${path}:fd=${newfd}:t=${nowMs()}`);
    tracked.set(newfd, { path, connId, createdAtMs: nowMs() });
    emitOpen(newfd, path, connId, how);
  }

  if (p_dup) {
    Interceptor.attach(p_dup, {
      onEnter(args) { this.oldfd = args[0].toInt32(); },
      onLeave(retval) {
        const newfd = retval.toInt32();
        if (newfd >= 0) cloneTrack(this.oldfd, newfd, 'dup');
      }
    });
  }

  if (p_dup2) {
    Interceptor.attach(p_dup2, {
      onEnter(args) {
        this.oldfd = args[0].toInt32();
        this.newfd = args[1].toInt32();
      },
      onLeave(retval) {
        const r = retval.toInt32();
        if (r >= 0) {
          // dup2 closes newfd first; ensure we drop any existing
          untrackFd(this.newfd, 'dup2:overwrite');
          cloneTrack(this.oldfd, this.newfd, 'dup2');
        }
      }
    });
  }

  if (p_dup3) {
    Interceptor.attach(p_dup3, {
      onEnter(args) {
        this.oldfd = args[0].toInt32();
        this.newfd = args[1].toInt32();
      },
      onLeave(retval) {
        const r = retval.toInt32();
        if (r >= 0) {
          untrackFd(this.newfd, 'dup3:overwrite');
          cloneTrack(this.oldfd, this.newfd, 'dup3');
        }
      }
    });
  }
}

function hookIo() {
  // send(int sockfd, const void *buf, size_t len, int flags);
  if (p_send) {
    Interceptor.attach(p_send, {
      onEnter(args) {
        const fd = args[0].toInt32();
        if (!tracked.has(fd)) return;
        const buf = args[1];
        let len = args[2].toUInt32();
        if (len === 0) return;
        if (len > maxBytes) len = maxBytes;
        try {
          const bytes = buf.readByteArray(len);
          emitData(fd, 'out', bytes);
        } catch (_) {}
      }
    });
  }

  // write(int fd, const void *buf, size_t count);
  if (p_write) {
    Interceptor.attach(p_write, {
      onEnter(args) {
        const fd = args[0].toInt32();
        if (!tracked.has(fd)) return;
        const buf = args[1];
        let len = args[2].toUInt32();
        if (len === 0) return;
        if (len > maxBytes) len = maxBytes;
        try {
          const bytes = buf.readByteArray(len);
          emitData(fd, 'out', bytes);
        } catch (_) {}
      }
    });
  }

  // recv(int sockfd, void *buf, size_t len, int flags);
  if (p_recv) {
    Interceptor.attach(p_recv, {
      onEnter(args) {
        this.fd = args[0].toInt32();
        if (!tracked.has(this.fd)) { this.fd = -1; return; }
        this.buf = args[1];
      },
      onLeave(retval) {
        if (this.fd < 0) return;
        const n = retval.toInt32();
        if (n <= 0) return;
        const cap = (n > maxBytes) ? maxBytes : n;
        try {
          const bytes = this.buf.readByteArray(cap);
          emitData(this.fd, 'in', bytes);
        } catch (_) {}
      }
    });
  }

  // read(int fd, void *buf, size_t count);
  if (p_read) {
    Interceptor.attach(p_read, {
      onEnter(args) {
        this.fd = args[0].toInt32();
        if (!tracked.has(this.fd)) { this.fd = -1; return; }
        this.buf = args[1];
      },
      onLeave(retval) {
        if (this.fd < 0) return;
        const n = retval.toInt32();
        if (n <= 0) return;
        const cap = (n > maxBytes) ? maxBytes : n;
        try {
          const bytes = this.buf.readByteArray(cap);
          emitData(this.fd, 'in', bytes);
        } catch (_) {}
      }
    });
  }
}

// Best-effort: periodically re-check pending connects using getpeername
function startPendingSweeper() {
  const intervalMs = CFG.pending_sweep_ms || 250;
  setInterval(function () {
    if (pendingConnect.size === 0) return;
    for (const [fd, info] of pendingConnect.entries()) {
      if (tracked.has(fd)) {
        pendingConnect.delete(fd);
        continue;
      }
      const path = getPeerUnixPath(fd);
      if (path && whitelist.has(path)) {
        trackFd(fd, path, 'pending:getpeername');
        pendingConnect.delete(fd);
      } else {
        // Drop stale pending after some time
        const age = nowMs() - info.sinceMs;
        if (age > (CFG.pending_ttl_ms || 5000)) {
          pendingConnect.delete(fd);
        }
      }
    }
  }, intervalMs);
}

// ---------- init ----------
(function main() {
  enumerateAlreadyOpenFds();
  hookConnect();
  hookCloseAndDup();
  hookIo();
  startPendingSweeper();

  send({
    type: 'init',
    libc_name: libcName,
    whitelist_count: whitelist.size,
    max_fds: maxFds,
    max_bytes: maxBytes,
    ts_ms: nowMs()
  });
})();
